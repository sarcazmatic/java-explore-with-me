package ru.practicum.api.user.service;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.core.codec.DecodingException;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import ru.practicum.client.WebClientService;import ru.practicum.dto.EndpointHitDtoRequest;import ru.practicum.dto.ViewStatsDtoResponse;import ru.practicum.dto.comment.*;import ru.practicum.dto.event.*;import ru.practicum.dto.request.EventRequestStatusUpdateRequest;import ru.practicum.dto.request.EventRequestStatusUpdateResult;import ru.practicum.dto.request.ParticipationRequestDto;import ru.practicum.dto.request.RequestMapper;import ru.practicum.exception.ForbiddenException;import ru.practicum.exception.NotFoundException;import ru.practicum.model.Event;import ru.practicum.model.Request;import ru.practicum.repository.*;import ru.practicum.utility.CommentStatus;import ru.practicum.utility.EWMDateTimePattern;import ru.practicum.utility.EventState;import ru.practicum.utility.RequestStatus;import javax.servlet.http.HttpServletRequest;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.*;import java.util.stream.Collectors;@Service@Slf4j@RequiredArgsConstructorpublic class PrivateEventsServiceImpl implements PrivateEventsService {    private final EventRepository eventRepository;    private final UserRepository userRepository;    private final CategoryRepository categoryRepository;    private final RequestRepository requestRepository;    private final CommentRepository commentRepository;    private final WebClientService baseClient;    @Override    @Transactional    public EventFullDto postEvent(long userId, NewEventDto newEventDto) {        log.info("Создается Event {} от User {}", newEventDto, userId);        Event newEvent = EventMapper.fromNewEventDto(newEventDto);        newEvent.setInitiator(userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        ));        newEvent.setCategory(categoryRepository.findById(newEventDto.getCategory()).orElseThrow(                () -> new NotFoundException("Категория не найдена!")        ));        return EventMapper.toEventFullDto(eventRepository.save(newEvent));    }    @Override    @Transactional    public List<EventShortDto> getEvents(long userId, Pageable pageable, HttpServletRequest httpServletRequest) {        log.info("Выводим список Event от User {}", userId);        List<Event> events = eventRepository.findAllByInitiatorId(userId, pageable);        if (events.isEmpty()) {            throw new NotFoundException("Не найдено событий от указанного пользователя");        }        for (Event e : events) {            if (e.getState() == EventState.PUBLISHED) {                EndpointHitDtoRequest endpointHitDtoRequest = EndpointHitDtoRequest.builder()                        .timestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(EWMDateTimePattern.FORMATTER)))                        .uri(httpServletRequest.getRequestURI() + "/" + e.getId())                        .app("ewm-main-service")                        .ip(httpServletRequest.getRemoteAddr()).build();                try {                    baseClient.postHit(endpointHitDtoRequest.getApp(),                            endpointHitDtoRequest.getUri(),                            endpointHitDtoRequest.getIp(),                            endpointHitDtoRequest.getTimestamp());                } catch (DecodingException ignored) {                    log.warn("Произошла ошибка кодировки при обращении к клиенту статистики!");                }            }        }        List<EventShortDto> eventShortDtoList = events.stream().map(EventMapper::toEventShortDto).collect(Collectors.toList());        for (EventShortDto esd : eventShortDtoList) {            esd.setViews(setViewsToEventShortDtoList(esd, httpServletRequest));        }        return eventShortDtoList;    }    @Override    @Transactional    public EventFullDto getEventById(long userId, long eventId, HttpServletRequest httpServletRequest) {        log.info("Выводим Event {} от User {}", eventId, userId);        EventFullDto eventFullDto = EventMapper.toEventFullDto(eventRepository.findByInitiatorIdAndId(userId, eventId)                .orElseThrow(                        () -> new NotFoundException("Событие не найдено")                ));        if (eventFullDto.getState() == EventState.PUBLISHED) {            EndpointHitDtoRequest endpointHitDtoRequest = EndpointHitDtoRequest.builder()                    .timestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(EWMDateTimePattern.FORMATTER)))                    .uri(httpServletRequest.getRequestURI())                    .app("ewm-main-service")                    .ip(httpServletRequest.getRemoteAddr()).build();            try {                baseClient.postHit(endpointHitDtoRequest.getApp(),                        endpointHitDtoRequest.getUri(),                        endpointHitDtoRequest.getIp(),                        endpointHitDtoRequest.getTimestamp());            } catch (DecodingException ignored) {                log.warn("Произошла ошибка кодировки при обращении к клиенту статистики!");            }        }        eventFullDto.setConfirmedRequests(requestRepository.countAllByEventIdAndStatus(eventId, RequestStatus.CONFIRMED));        eventFullDto.setComments(setCommentsToEventFullDto(eventFullDto));        eventFullDto.setViews(setViewsToEventFullDto(httpServletRequest));        return eventFullDto;    }    @Override    @Transactional    public EventRequestStatusUpdateResult patchRequests(long userId,                                                        long eventId,                                                        EventRequestStatusUpdateRequest eventRequestStatusUpdateRequest,                                                        HttpServletRequest httpServletRequest) {        EventFullDto eventFullDto = getEventById(userId, eventId, httpServletRequest);        List<Request> requestStatusUpdateList = requestRepository.findAllByEventIdAndIdIn(eventId,                eventRequestStatusUpdateRequest.getRequestIds());        List<ParticipationRequestDto> confirmedRequests = new ArrayList<>();        List<ParticipationRequestDto> rejectedRequests = new ArrayList<>();        if (eventFullDto.getParticipantLimit() > 0) {            for (Request r : requestStatusUpdateList) {                if (eventFullDto.getConfirmedRequests() >= eventFullDto.getParticipantLimit())                    throw new ForbiddenException("Невозможно подтвердить новую заявку – достигнут лимит!");                Request request = requestRepository.findById(r.getId()).orElseThrow(                        () -> new NotFoundException("Запрос не найден!")                );                if (r.getStatus() != RequestStatus.PENDING)                    throw new ForbiddenException("Сменить статус можно только у заявок в статусе PENDING!");                request.setStatus(eventRequestStatusUpdateRequest.getStatus());                requestRepository.save(request);                if (request.getStatus() == RequestStatus.CONFIRMED) {                    confirmedRequests.add(RequestMapper.toParticipationRequestDto(request));                    eventFullDto.setConfirmedRequests(eventFullDto.getConfirmedRequests() + 1);                }                if (request.getStatus() == RequestStatus.REJECTED)                    rejectedRequests.add(RequestMapper.toParticipationRequestDto(request));            }        }        return EventRequestStatusUpdateResult.builder()                .confirmedRequests(confirmedRequests)                .rejectedRequests(rejectedRequests)                .build();    }    @Override    @Transactional    public EventFullDto patchEvent(long userId, long eventId, UpdateEventUserRequest updateEventUserRequest,                                   HttpServletRequest httpServletRequest) {        Event event = EventMapper.updateEventUserRequest(eventRepository.findById(eventId).orElseThrow(                () -> new NotFoundException("Событие не найдено")        ), updateEventUserRequest);        if (event.getInitiator().getId() != userId)            throw new ForbiddenException("Нельзя менять чужие события!");        if (updateEventUserRequest.getCategory() > 0)            event.setCategory(categoryRepository.findById(updateEventUserRequest.getCategory())                    .orElseThrow(() -> new NotFoundException("Категория не найдена")));        EventFullDto eventFullDto = EventMapper.toEventFullDto(eventRepository.save(event));        eventFullDto.setConfirmedRequests(requestRepository.countAllByEventIdAndStatus(eventId, RequestStatus.CONFIRMED));        eventFullDto.setComments(setCommentsToEventFullDto(eventFullDto));        eventFullDto.setViews(setViewsToEventFullDto(httpServletRequest));        return eventFullDto;    }    private long setViewsToEventFullDto(HttpServletRequest httpServletRequest) {        String path = (httpServletRequest.getRequestURI());        int charIndex = path.indexOf("/events");        long views = 0;        List<ViewStatsDtoResponse> list = baseClient.getStats(LocalDateTime.now().minusYears(100),                LocalDateTime.now().plusYears(100),                List.of(path.substring(charIndex)), true);        for (ViewStatsDtoResponse v : list) {            views = v.getHits();        }        return views;    }    private long setViewsToEventShortDtoList(EventShortDto eventShortDto, HttpServletRequest httpServletRequest) {        String path = (httpServletRequest.getRequestURI() + "/" + eventShortDto.getId());        int charIndex = path.indexOf("/events");        long views = 0;        List<ViewStatsDtoResponse> list = baseClient.getStats(LocalDateTime.now().minusYears(100),                LocalDateTime.now().plusYears(100),                List.of(path.substring(charIndex)), true);        for (ViewStatsDtoResponse v : list) {            views = v.getHits();        }        return views;    }    @Override    @Transactional    public List<ParticipationRequestDto> getRequestsForEvent(long userId, long eventId) {        if (!eventRepository.findAllByInitiatorId(userId, Pageable.unpaged()).contains(eventRepository.findById(eventId)                .orElseThrow(() -> new NotFoundException("У данного пользователя не инициировано событий"))))            throw new NotFoundException("Данное событие инициировано другим пользователем");        return requestRepository.findAllByEventId(eventId).stream()                .map(RequestMapper::toParticipationRequestDto)                .collect(Collectors.toList());    }    private List<CommentDtoShort> setCommentsToEventFullDto(EventFullDto eventFullDto) {        return commentRepository.findAllByEventIdAndCommentStatus(                        eventFullDto.getId(), CommentStatus.CONFIRMED                ).stream()                .map(CommentMapper::toCommentDtoShort).collect(Collectors.toList());    }}
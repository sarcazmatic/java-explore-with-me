package ru.practicum.api.user.service;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.core.codec.DecodingException;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import ru.practicum.client.WebClientService;import ru.practicum.dto.EndpointHitDtoRequest;import ru.practicum.dto.comment.*;import ru.practicum.dto.event.*;import ru.practicum.dto.request.EventRequestStatusUpdateRequest;import ru.practicum.dto.request.EventRequestStatusUpdateResult;import ru.practicum.dto.request.ParticipationRequestDto;import ru.practicum.dto.request.RequestMapper;import ru.practicum.dto.user.UserMapper;import ru.practicum.exception.ForbiddenException;import ru.practicum.exception.NotFoundException;import ru.practicum.exception.ValidationException;import ru.practicum.model.Comment;import ru.practicum.model.Event;import ru.practicum.model.Request;import ru.practicum.model.User;import ru.practicum.repository.*;import ru.practicum.utility.CommentStatus;import ru.practicum.utility.EWMDateTimePattern;import ru.practicum.utility.EventState;import ru.practicum.utility.RequestStatus;import javax.servlet.http.HttpServletRequest;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.*;import java.util.stream.Collectors;@Service@Slf4j@RequiredArgsConstructorpublic class PrivateEventsServiceImpl implements PrivateEventsService {    private final EventRepository eventRepository;    private final UserRepository userRepository;    private final CategoryRepository categoryRepository;    private final RequestRepository requestRepository;    private final CommentRepository commentRepository;    private final WebClientService baseClient;    @Override    @Transactional    public EventFullDto postEvent(long userId, NewEventDto newEventDto) {        log.info("Создается Event {} от User {}", newEventDto, userId);        Event newEvent = EventMapper.fromNewEventDto(newEventDto);        newEvent.setInitiator(userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        ));        newEvent.setCategory(categoryRepository.findById(newEventDto.getCategory()).orElseThrow(                () -> new NotFoundException("Категория не найдена!")        ));        return EventMapper.toEventFullDto(eventRepository.save(newEvent));    }    @Override    @Transactional    public List<EventShortDto> getEvents(long userId, Pageable pageable, HttpServletRequest httpServletRequest) {        log.info("Выводим список Event от User {}", userId);        List<Event> events = eventRepository.findAllByInitiatorId(userId, pageable);        for (Event e : events) {            if (e.getState() == EventState.PUBLISHED) {                EndpointHitDtoRequest endpointHitDtoRequest = EndpointHitDtoRequest.builder()                        .timestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(EWMDateTimePattern.FORMATTER)))                        .uri(httpServletRequest.getRequestURI() + "/" + e.getId())                        .app("ewm-main-service")                        .ip(httpServletRequest.getRemoteAddr()).build();                try {                    baseClient.postHit(endpointHitDtoRequest.getApp(),                            endpointHitDtoRequest.getUri(),                            endpointHitDtoRequest.getIp(),                            endpointHitDtoRequest.getTimestamp());                } catch (DecodingException ignored) {                    log.warn("Произошла ошибка кодировки при обращении к клиенту статистики!");                }            }        }        List<EventShortDto> eventShortDtoList = events.stream().map(EventMapper::toEventShortDto).collect(Collectors.toList());        for (EventShortDto esd : eventShortDtoList) {            try {                esd.setViews(setViewsToEventShortDtoList(esd, httpServletRequest));            } catch (IndexOutOfBoundsException ignored) {                log.warn("Произошла ошибка при обращении к клиенту статистики!");            }        }        return eventShortDtoList;    }    @Override    @Transactional    public EventFullDto getEventById(long userId, long eventId, HttpServletRequest httpServletRequest) {        log.info("Выводим Event {} от User {}", eventId, userId);        EventFullDto eventFullDto = EventMapper.toEventFullDto(eventRepository.findByInitiatorIdAndId(userId, eventId)                .orElseThrow(                        () -> new NotFoundException("Событие не найдено")                ));        if (eventFullDto.getState() == EventState.PUBLISHED) {            EndpointHitDtoRequest endpointHitDtoRequest = EndpointHitDtoRequest.builder()                    .timestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(EWMDateTimePattern.FORMATTER)))                    .uri(httpServletRequest.getRequestURI())                    .app("ewm-main-service")                    .ip(httpServletRequest.getRemoteAddr()).build();            try {                baseClient.postHit(endpointHitDtoRequest.getApp(),                        endpointHitDtoRequest.getUri(),                        endpointHitDtoRequest.getIp(),                        endpointHitDtoRequest.getTimestamp());            } catch (DecodingException ignored) {                log.warn("Произошла ошибка кодировки при обращении к клиенту статистики!");            }        }        eventFullDto.setConfirmedRequests(requestRepository.countAllByEventIdAndStatus(eventId, RequestStatus.CONFIRMED));        eventFullDto.setComments(setCommentsToEventFullDto(eventFullDto));        try {            eventFullDto.setViews(setViewsToEventFullDto(httpServletRequest));        } catch (IndexOutOfBoundsException ignore) {            log.warn("Произошла ошибка при обращении к клиенту статистики!");        }        return eventFullDto;    }    @Override    @Transactional    public EventRequestStatusUpdateResult patchRequests(long userId, long eventId, EventRequestStatusUpdateRequest eventRequestStatusUpdateRequest, HttpServletRequest httpServletRequest) {        EventFullDto eventFullDto = getEventById(userId, eventId, httpServletRequest);        List<Request> requestStatusUpdateList = requestRepository.findAllByEventIdAndIdIn(eventId, eventRequestStatusUpdateRequest.getRequestIds());        List<ParticipationRequestDto> confirmedRequests = new ArrayList<>();        List<ParticipationRequestDto> rejectedRequests = new ArrayList<>();        if (eventFullDto.getParticipantLimit() > 0) {            for (Request r : requestStatusUpdateList) {                if (eventFullDto.getConfirmedRequests() >= eventFullDto.getParticipantLimit())                    throw new ForbiddenException("Невозможно подтвердить новую заявку – достигнут лимит");                Request request = requestRepository.findById(r.getId()).orElseThrow(                        () -> new NotFoundException("Запрос не найден")                );                if (r.getStatus() != RequestStatus.PENDING)                    throw new ForbiddenException("Сменить статус можно только у заявок в статусе PENDING!");                request.setStatus(eventRequestStatusUpdateRequest.getStatus());                requestRepository.save(request);                if (request.getStatus() == RequestStatus.CONFIRMED) {                    confirmedRequests.add(RequestMapper.toParticipationRequestDto(request));                    eventFullDto.setConfirmedRequests(eventFullDto.getConfirmedRequests() + 1);                }                if (request.getStatus() == RequestStatus.REJECTED)                    rejectedRequests.add(RequestMapper.toParticipationRequestDto(request));            }        }        return EventRequestStatusUpdateResult.builder()                .confirmedRequests(confirmedRequests)                .rejectedRequests(rejectedRequests)                .build();    }    @Override    @Transactional    public EventFullDto patchEvent(long userId, long eventId, UpdateEventUserRequest updateEventUserRequest,                                   HttpServletRequest httpServletRequest) {        Event event = EventMapper.updateEventUserRequest(eventRepository.findById(eventId).orElseThrow(                () -> new NotFoundException("Событие не найдено")        ), updateEventUserRequest);        if (event.getInitiator().getId() != userId)            throw new ForbiddenException("Нельзя менять чужие события!");        if (updateEventUserRequest.getCategory() > 0)            event.setCategory(categoryRepository.findById(updateEventUserRequest.getCategory())                    .orElseThrow(() -> new NotFoundException("Категория не найдена")));        EventFullDto eventFullDto = EventMapper.toEventFullDto(eventRepository.save(event));        eventFullDto.setConfirmedRequests(requestRepository.countAllByEventIdAndStatus(eventId, RequestStatus.CONFIRMED));        eventFullDto.setComments(setCommentsToEventFullDto(eventFullDto));        try {            eventFullDto.setViews(setViewsToEventFullDto(httpServletRequest));        } catch (IndexOutOfBoundsException ignored) {            log.warn("Произошла ошибка при обращении к клиенту статистики!");        }        return eventFullDto;    }    private long setViewsToEventFullDto(HttpServletRequest httpServletRequest) throws IndexOutOfBoundsException {        return baseClient.getStats(LocalDateTime.now().minusYears(100),                LocalDateTime.now().plusYears(100),                List.of(httpServletRequest.getRequestURI()),                true).get(0).getHits();    }    private long setViewsToEventShortDtoList(EventShortDto eventShortDto, HttpServletRequest httpServletRequest) throws IndexOutOfBoundsException {        return baseClient.getStats(LocalDateTime.now().minusYears(100),                LocalDateTime.now().plusYears(100),                List.of(httpServletRequest.getRequestURI() + "/" + eventShortDto.getId()),                true).get(0).getHits();    }    @Override    @Transactional    public List<ParticipationRequestDto> getRequestsForEvent(long userId, long eventId) {        if (!eventRepository.findAllByInitiatorId(userId, Pageable.unpaged()).contains(eventRepository.findById(eventId)                .orElseThrow(() -> new NotFoundException("У данного пользователя не инициировано событий"))))            throw new NotFoundException("Данное событие инициировано другим пользователем");        return requestRepository.findAllByEventId(eventId).stream()                .map(RequestMapper::toParticipationRequestDto)                .collect(Collectors.toList());    }    @Override    @Transactional    public CommentDtoResponse postNewComment(long userId, long eventId, NewCommentDto newCommentDto) {        User commenter = userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        );        Event event = eventRepository.findById(eventId).orElseThrow(                () -> new NotFoundException("Событие не найдено!")        );        if (event.getState() != EventState.PUBLISHED)            throw new ValidationException("Комментарии можно оставлять только к опубликованным событиям!");        Comment comment = CommentMapper.fromNewCommentDto(newCommentDto);        comment.setEvent(event);        comment.setCommenter(commenter);        CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(commentRepository.save(comment));        commentDtoResponse.setCommenter(UserMapper.toUserShortDto(commenter));        commentDtoResponse.setEvent(EventMapper.toEventShortDto(event));        return commentDtoResponse;    }    @Override    @Transactional    public CommentStatusUpdateResult patchStatusComments(long userId,                                                         long eventId,                                                         CommentStatusUpdateRequest commentStatusUpdateRequest) {        if (eventRepository.findById(eventId).orElseThrow(                (() -> new NotFoundException("Событие не найдено!"))).getInitiator().getId() != userId) {            throw new ValidationException("Модерировать можно только комментарии к событиям, созданным вами!");        }        List<Comment> comments = commentRepository.findAllByIdIn(commentStatusUpdateRequest.getCommentIds());        List<CommentDtoResponse> commentDtoResponseConfirmedList = new ArrayList<>();        List<CommentDtoResponse> commentDtoResponseRejectedList = new ArrayList<>();        for (Comment c : comments) {            if (c.getCommentStatus() == commentStatusUpdateRequest.getStatus()) {                log.error("У комментария с id {} установлен такой же статус!", c.getId());            } else {                c.setCommentStatus(commentStatusUpdateRequest.getStatus());                CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(c);                commentDtoResponse.setCommenter(UserMapper.toUserShortDto(userRepository.findById(c.getCommenter().getId()).orElseThrow(                        () -> new NotFoundException("Пользователь не найден!")                )));                commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(eventId).orElseThrow(                        () -> new NotFoundException("Событие не найдено!")                )));                if (c.getCommentStatus() == CommentStatus.CONFIRMED) {                    commentDtoResponseConfirmedList.add(commentDtoResponse);                } else if (c.getCommentStatus() == CommentStatus.REJECTED) {                    commentDtoResponseRejectedList.add(commentDtoResponse);                }                commentRepository.save(c);            }        }        return CommentStatusUpdateResult.builder()                .confirmedRequests(commentDtoResponseConfirmedList)                .rejectedRequests(commentDtoResponseRejectedList)                .build();    }    private List<CommentDtoShort> setCommentsToEventFullDto(EventFullDto eventFullDto) {        return commentRepository.findAllByEventIdAndCommentStatus(                        eventFullDto.getId(), CommentStatus.CONFIRMED                ).stream()                .map(CommentMapper::toCommentDtoShort).collect(Collectors.toList());    }}
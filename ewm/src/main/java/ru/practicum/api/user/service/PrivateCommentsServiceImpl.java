package ru.practicum.api.user.service;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import ru.practicum.dto.comment.*;import ru.practicum.dto.event.*;import ru.practicum.dto.user.UserMapper;import ru.practicum.dto.user.UserShortDto;import ru.practicum.exception.NotFoundException;import ru.practicum.exception.ValidationException;import ru.practicum.model.Comment;import ru.practicum.repository.*;import ru.practicum.utility.CommentStatus;import java.util.ArrayList;import java.util.List;@Service@Slf4j@RequiredArgsConstructorpublic class PrivateCommentsServiceImpl implements PrivateCommentsService {    private final UserRepository userRepository;    private final CommentRepository commentRepository;    private final EventRepository eventRepository;    @Override    public List<CommentDtoResponse> getCommentByUserId(long userId) {        List<Comment> comments = commentRepository.findByCommenterId(userId);        List<CommentDtoResponse> commentDtoResponseList = new ArrayList<>();        UserShortDto commenter = UserMapper.toUserShortDto(userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        ));        for (Comment c : comments) {            CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(c);            commentDtoResponse.setCommenter(commenter);            commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(c.getEvent().getId()).orElseThrow(                    () -> new NotFoundException("Событие не найдено!")            )));            commentDtoResponseList.add(commentDtoResponse);        }        return commentDtoResponseList;    }    @Override    public CommentDtoResponse patchCancelComment(long userId, long commentId) {        Comment comment = commentRepository.findById(commentId).orElseThrow(                () -> new NotFoundException("Комментарий не найден!")        );        if (comment.getCommenter().getId() != userId) {            throw new ValidationException("Отменить можно только свой комментарий");        }        if (comment.getCommentStatus() == CommentStatus.CANCELED || comment.getCommentStatus() == CommentStatus.REJECTED) {            throw new ValidationException("Нельзя отменить отвергнутые или уже отмененные комментарии!");        }        comment.setCommentStatus(CommentStatus.CANCELED);        commentRepository.save(comment);        CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(comment);        commentDtoResponse.setCommenter(UserMapper.toUserShortDto(userRepository.findById(comment.getCommenter().getId()).orElseThrow(                () -> new NotFoundException("Пользователь не найдено!")        )));        commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(comment.getEvent().getId()).orElseThrow(                () -> new NotFoundException("Событие не найдено!")        )));        return commentDtoResponse;    }    @Override    public void deleteComment(long userId, long commentId) {        Comment comment = commentRepository.findById(commentId).orElseThrow(                () -> new NotFoundException("Комментарий не найден!")        );        if (comment.getCommenter().getId() != userId) {            throw new ValidationException("Удалить можно только свой комментарий");        }        commentRepository.deleteById(commentId);    }}
package ru.practicum.api.user.service;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import ru.practicum.dto.comment.*;import ru.practicum.dto.event.*;import ru.practicum.dto.user.UserMapper;import ru.practicum.dto.user.UserShortDto;import ru.practicum.exception.NotFoundException;import ru.practicum.exception.ValidationException;import ru.practicum.model.Comment;import ru.practicum.model.Event;import ru.practicum.model.User;import ru.practicum.repository.*;import ru.practicum.utility.CommentStatus;import ru.practicum.utility.EventState;import java.util.ArrayList;import java.util.List;@Service@Slf4j@RequiredArgsConstructorpublic class PrivateCommentsServiceImpl implements PrivateCommentsService {    private final UserRepository userRepository;    private final CommentRepository commentRepository;    private final EventRepository eventRepository;    @Override    public List<CommentDtoResponse> getCommentByUserId(long userId) {        List<Comment> comments = commentRepository.findByCommenterId(userId);        List<CommentDtoResponse> commentDtoResponseList = new ArrayList<>();        UserShortDto commenter = UserMapper.toUserShortDto(userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        ));        for (Comment c : comments) {            CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(c);            commentDtoResponse.setCommenter(commenter);            commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(c.getEvent().getId()).orElseThrow(                    () -> new NotFoundException("Событие не найдено!")            )));            commentDtoResponseList.add(commentDtoResponse);        }        return commentDtoResponseList;    }    @Override    public CommentDtoResponse patchCancelComment(long userId, long commentId) {        Comment comment = commentRepository.findById(commentId).orElseThrow(                () -> new NotFoundException("Комментарий не найден!")        );        if (comment.getCommenter().getId() != userId) {            throw new ValidationException("Отменить можно только свой комментарий");        }        if (comment.getCommentStatus() == CommentStatus.CANCELED || comment.getCommentStatus() == CommentStatus.REJECTED) {            throw new ValidationException("Нельзя отменить отвергнутые или уже отмененные комментарии!");        }        comment.setCommentStatus(CommentStatus.CANCELED);        commentRepository.save(comment);        CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(comment);        commentDtoResponse.setCommenter(UserMapper.toUserShortDto(userRepository.findById(comment.getCommenter().getId()).orElseThrow(                () -> new NotFoundException("Пользователь не найдено!")        )));        commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(comment.getEvent().getId()).orElseThrow(                () -> new NotFoundException("Событие не найдено!")        )));        return commentDtoResponse;    }    @Override    public void deleteComment(long userId, long commentId) {        Comment comment = commentRepository.findById(commentId).orElseThrow(                () -> new NotFoundException("Комментарий не найден!")        );        if (comment.getCommenter().getId() != userId) {            throw new ValidationException("Удалить можно только свой комментарий");        }        commentRepository.deleteById(commentId);    }    @Override    @Transactional    public CommentDtoResponse postNewComment(long userId, long eventId, NewCommentDto newCommentDto) {        User commenter = userRepository.findById(userId).orElseThrow(                () -> new NotFoundException("Пользователь не найден!")        );        Event event = eventRepository.findById(eventId).orElseThrow(                () -> new NotFoundException("Событие не найдено!")        );        if (event.getState() != EventState.PUBLISHED)            throw new ValidationException("Комментарии можно оставлять только к опубликованным событиям!");        Comment comment = CommentMapper.fromNewCommentDto(newCommentDto);        comment.setEvent(event);        comment.setCommenter(commenter);        CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(commentRepository.save(comment));        commentDtoResponse.setCommenter(UserMapper.toUserShortDto(commenter));        commentDtoResponse.setEvent(EventMapper.toEventShortDto(event));        return commentDtoResponse;    }    @Override    @Transactional    public CommentStatusUpdateResult patchStatusComments(long userId,                                                         long eventId,                                                         CommentStatusUpdateRequest commentStatusUpdateRequest) {        if (eventRepository.findById(eventId).orElseThrow(                (() -> new NotFoundException("Событие не найдено!"))).getInitiator().getId() != userId) {            throw new ValidationException("Модерировать можно только комментарии к событиям, созданным вами!");        }        List<Comment> comments = commentRepository.findAllByIdIn(commentStatusUpdateRequest.getCommentIds());        List<CommentDtoResponse> commentDtoResponseConfirmedList = new ArrayList<>();        List<CommentDtoResponse> commentDtoResponseRejectedList = new ArrayList<>();        for (Comment c : comments) {            if (c.getCommentStatus() == commentStatusUpdateRequest.getStatus()) {                log.error("У комментария с id {} установлен такой же статус!", c.getId());            } else {                c.setCommentStatus(commentStatusUpdateRequest.getStatus());                CommentDtoResponse commentDtoResponse = CommentMapper.toCommentDtoResponse(c);                commentDtoResponse.setCommenter(UserMapper.toUserShortDto(userRepository.findById(c.getCommenter().getId()).orElseThrow(                        () -> new NotFoundException("Пользователь не найден!")                )));                commentDtoResponse.setEvent(EventMapper.toEventShortDto(eventRepository.findById(eventId).orElseThrow(                        () -> new NotFoundException("Событие не найдено!")                )));                if (c.getCommentStatus() == CommentStatus.CONFIRMED) {                    commentDtoResponseConfirmedList.add(commentDtoResponse);                } else if (c.getCommentStatus() == CommentStatus.REJECTED) {                    commentDtoResponseRejectedList.add(commentDtoResponse);                }                commentRepository.save(c);            }        }        return CommentStatusUpdateResult.builder()                .confirmedRequests(commentDtoResponseConfirmedList)                .rejectedRequests(commentDtoResponseRejectedList)                .build();    }}